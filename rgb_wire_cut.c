// rgb_wire_cut.c  – “Cut-the-wire” mini-game for Raspberry Pi Pico W

#include <stdio.h>
#include <stdlib.h>
#include <string.h>

#include "pico/stdlib.h"
#include "pico/time.h"
#include "hardware/adc.h"
#include "hardware/i2c.h"
#include "hardware/pio.h"
#include "hardware/clocks.h"

#include "ssd1306_font.h"    // your SSD1306 text helpers
#include "ws2812.pio.h"      // generated by CMake

// ─────────────── Configurable ────────────────────────────────────────────────
#define LED_PIN       0       // WS2812 data pin (GP0)
#define NUM_LEDS      8
#define WS2812_FREQ   800000  // 800 kHz

#define JOY_ADC_CH    0       // VRx → ADC0 (GP26)
#define JOY_THRESHOLD 200     // ADC dead-zone around center
#define CURSOR_STEP_MS 120    // repeat delay when holding stick

#define BUTTON_PIN   14       // “Cut” button on GP14

#define OLED_WIDTH   128
#define OLED_HEIGHT   64
#define OLED_I2C_BUS  i2c0
#define OLED_SDA_PIN  16
#define OLED_SCL_PIN  17
#define OLED_ADDR     0x3C

// ─────────────── PIO WS2812 Helpers ─────────────────────────────────────────
static inline void ws2812_program_init_wrap(PIO pio, uint sm, uint offset, uint pin) {
    // default config: shift right, autopull 24 bits, fifo joined
    pio_sm_config c = ws2812_program_get_default_config(offset);
    sm_config_set_out_shift(&c, false, true, 24);
    sm_config_set_fifo_join(&c, PIO_FIFO_JOIN_TX);

    // configure clock divider for WS2812_FREQ
    float clock_hz = (float)clock_get_hz(clk_sys);
    int cycles = ws2812_T1 + ws2812_T2 + ws2812_T3;  // from generated header
    sm_config_set_clkdiv(&c, clock_hz / (WS2812_FREQ * cycles));

    // init pin and state machine
    pio_gpio_init(pio, pin);
    gpio_set_dir(pin, GPIO_OUT);
    sm_config_set_set_pins(&c, pin, 1);
    pio_sm_init(pio, sm, offset, &c);
    pio_sm_set_enabled(pio, sm, true);
}

static inline uint32_t ws_color(uint8_t r, uint8_t g, uint8_t b){
    // GRB order: green in highest byte
    return ((uint32_t)g<<24) | ((uint32_t)r<<16) | ((uint32_t)b<<8);
}

static void ring_show(PIO pio, uint sm, int cursor, int target_color){
    const uint32_t off_col = ws_color(4,4,4);
    static const uint32_t on_cols[3] = {
        [0] = 0x00FF0000,  // green
        [1] = 0x0000FF00,  // blue
        [2] = 0x000000FF   // red
    };
    uint32_t on_col = on_cols[target_color];

    for(int i = 0; i < NUM_LEDS; ++i){
        pio_sm_put_blocking(pio, sm, i == cursor ? on_col : off_col);
    }
}

// ─────────────── OLED Helpers ────────────────────────────────────────────────
#define FB_SIZE (OLED_WIDTH * OLED_HEIGHT / 8)
static uint8_t fb[FB_SIZE];

static void oled_cmd(uint8_t c){
    uint8_t buf[2] = {0x80, c};
    i2c_write_blocking(OLED_I2C_BUS, OLED_ADDR, buf, 2, false);
}

static void oled_data(const uint8_t *d, size_t n){
    uint8_t chunk[17] = {0x40};
    while(n){
        size_t m = n > 16 ? 16 : n;
        memcpy(chunk+1, d, m);
        i2c_write_blocking(OLED_I2C_BUS, OLED_ADDR, chunk, m+1, false);
        d += m; n -= m;
    }
}

static inline void fb_px(int x, int y, bool on){
    if((u_int)x>=OLED_WIDTH||(u_int)y>=OLED_HEIGHT) return;
    uint32_t idx = (y>>3)*OLED_WIDTH + x;
    uint8_t mask = 1u << (y & 7);
    fb[idx] = on ? (fb[idx] | mask) : (fb[idx] & ~mask);
}

static void oled_refresh(void){
    const uint8_t cfg[] = {0x21,0,OLED_WIDTH-1,0x22,0,OLED_HEIGHT/8-1};
    for(int i=0;i<6;i++) oled_cmd(cfg[i]);
    oled_data(fb, FB_SIZE);
}

static void oled_clear(void){
    memset(fb,0,FB_SIZE);
    oled_refresh();
}

static void oled_init(void){
    // standard SSD1306 init sequence
    static const uint8_t init_seq[] = {
        0xAE,0x20,0x00,0xA1,0xC8,0xDA,0x12,0xA8,OLED_HEIGHT-1,
        0xD3,0x00,0xD5,0x80,0xD9,0xF1,0xDB,0x20,0xA4,0xA6
    };
    i2c_init(OLED_I2C_BUS, 100000);
    gpio_set_function(OLED_SDA_PIN, GPIO_FUNC_I2C);
    gpio_set_function(OLED_SCL_PIN, GPIO_FUNC_I2C);
    gpio_pull_up(OLED_SDA_PIN); gpio_pull_up(OLED_SCL_PIN);
    for(size_t i=0;i<sizeof(init_seq);++i) oled_cmd(init_seq[i]);
    oled_clear();
}

// text helpers from ssd1306_font.h
static int glyph_index(char c){
    if(c>='A'&&c<='Z') return 1+(c-'A');
    if(c>='a'&&c<='z') return 1+(c-'a');
    if(c>='0'&&c<='9') return 27+(c-'0');
    if(c=='!') return 37;
    if(c=='-') return 38;
    return 0;
}
static void draw_char(int x,int y,char c){
    const uint8_t *f = &font[glyph_index(c)*8];
    for(int cx=0;cx<8;++cx)
        for(int cy=0;cy<8;++cy)
            fb_px(x+cx,y+cy, (f[cx]&(1u<<cy)) );
}
static void draw_str(int x,int y,const char *s){
    for(;*s;++s, x+=8) draw_char(x,y,*s);
}
static void draw_center(int y,const char *s){
    int w = strlen(s)*8;
    draw_str((OLED_WIDTH-w)/2, y, s);
}

// ─────────────── Helpers ─────────────────────────────────────────────────────
static int read_joystick(){
    adc_select_input(JOY_ADC_CH);
    int raw = adc_read() - 2048;
    if (raw >  JOY_THRESHOLD) return +1;
    if (raw < -JOY_THRESHOLD) return -1;
    return 0;
}

// ─────────────── Main ────────────────────────────────────────────────────────
int main(){
    stdio_init_all();
    sleep_ms(100);

    // init peripherals
    oled_init();
    gpio_init(BUTTON_PIN); gpio_set_dir(BUTTON_PIN, GPIO_IN); gpio_pull_up(BUTTON_PIN);
    adc_init(); adc_gpio_init(26);

    // init PIO+WS2812
    PIO pio = pio0;
    uint offset = pio_add_program(pio, &ws2812_program);
    uint sm     = pio_claim_unused_sm(pio, true);
    ws2812_program_init_wrap(pio, sm, offset, LED_PIN);

    // pick random target
    srand((uint32_t)time_us_32());
    int8_t color = rand() % 3;
    int8_t target = rand() % NUM_LEDS;
    static const char *names[3] = {"GREEN","BLUE","RED"};

    // title screen
    oled_clear();
    draw_center((OLED_HEIGHT/2)-16, "CUT THE");
    draw_center((OLED_HEIGHT/2)- 8, names[color]);
    draw_center((OLED_HEIGHT/2)+ 0, "WIRE");
    oled_refresh();

    // cursor control
    int cursor = 0;
    absolute_time_t next_move = get_absolute_time();

    while (1) {
        // step cursor if held
        int dir = read_joystick();
        if (absolute_time_diff_us(next_move, get_absolute_time()) < 0) {
            if (dir) {
                cursor = (cursor + dir + NUM_LEDS) % NUM_LEDS;
                next_move = delayed_by_ms(get_absolute_time(), CURSOR_STEP_MS);
            }
        }

        // update ring
        ring_show(pio, sm, cursor, color);

        // handle cut button
        if (!gpio_get(BUTTON_PIN)) {
            bool success = (cursor == target);
            uint8_t code = (color<<4) | cursor;

            // flash result
            for (int i=0; i<3; ++i) {
                uint32_t c = success
                    ? ws_color(0,80,0)
                    : ws_color(80,0,0);
                for(int j=0;j<NUM_LEDS;++j) pio_sm_put_blocking(pio, sm, c);
                sleep_ms(80);
                for(int j=0;j<NUM_LEDS;++j) pio_sm_put_blocking(pio, sm, 0);
                sleep_ms(80);
            }

            // result screen
            oled_clear();
            draw_center((OLED_HEIGHT/2)-4, success ? "DEFUSED!" : "BOOM!");
            oled_refresh();

            printf("wire_code=0x%02X\n", code);
            tight_loop_contents();
        }

        tight_loop_contents();
    }

    return 0;
}
